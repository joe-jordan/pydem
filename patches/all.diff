Index: python/lammps.py
===================================================================
--- python/lammps.py	(revision 8389)
+++ python/lammps.py	(working copy)
@@ -15,6 +15,7 @@
 
 import types
 from ctypes import *
+import os.path
 
 LMPINT = 0
 LMPDOUBLE = 1
@@ -22,19 +23,21 @@
 LMPDPTR = 3
 LMPDPTRPTR = 4
 
+LOCATION = os.path.dirname(__file__)
+
 class lammps:
   def __init__(self,args=None):
-
+    
     # attempt to load parallel library first, serial library next
     # could provide caller a flag to choose which library to load
     
     try:
-      self.lib = CDLL("_lammps.so")
+      self.lib = CDLL(os.path.join(LOCATION, "_lammps.so"))
     except:
-      try:
-        self.lib = CDLL("_lammps_serial.so")
-      except:
-        raise OSError,"Could not load LAMMPS dynamic library"
+      #try:
+      self.lib = CDLL(os.path.join(LOCATION, "_lammps_serial.so"))
+      #except:
+        #raise OSError,"Could not load LAMMPS dynamic library"
 
     # create an instance of LAMMPS
     # don't know how to pass an MPI communicator from PyPar
@@ -52,20 +55,20 @@
       self.lib.lammps_open_no_mpi(0,None,byref(self.lmp))
       # could use just this if LAMMPS lib interface supported it
       # self.lmp = self.lib.lammps_open_no_mpi(0,None)
-
+  
   def __del__(self):
     if self.lmp: self.lib.lammps_close(self.lmp)
-
+  
   def close(self):
     self.lib.lammps_close(self.lmp)
     self.lmp = None
-
+  
   def file(self,file):
     self.lib.lammps_file(self.lmp,file)
-
+  
   def command(self,cmd):
     self.lib.lammps_command(self.lmp,cmd)
-
+  
   def extract_global(self,name,type):
     if type == LMPDOUBLE:
       self.lib.lammps_extract_global.restype = POINTER(c_double)
@@ -76,7 +79,7 @@
       ptr = self.lib.lammps_extract_global(self.lmp,name)
       return ptr[0]
     return None
-
+  
   def extract_atom(self,name,type):
     if type == LMPDPTRPTR:
       self.lib.lammps_extract_atom.restype = POINTER(POINTER(c_double))
@@ -91,7 +94,7 @@
       ptr = self.lib.lammps_extract_atom(self.lmp,name)
       return ptr
     return None
-
+  
   def extract_compute(self,id,style,type):
     if type == 0:
       if style > 0: return None
@@ -107,7 +110,7 @@
       ptr = self.lib.lammps_extract_compute(self.lmp,id,style,type)
       return ptr
     return None
-
+  
   # in case of global datum, free memory for 1 double via lammps_free()
   # double was allocated by library interface function
   
@@ -128,7 +131,7 @@
       ptr = self.lib.lammps_extract_fix(self.lmp,id,style,type,i,j)
       return ptr
     return None
-
+  
   # free memory for 1 double or 1 vector of doubles via lammps_free()
   # for vector, must copy nlocal returned values to local c_double vector
   # memory was allocated by library interface function
@@ -151,16 +154,16 @@
       self.lib.lammps_free(ptr)
       return result
     return None
-
+  
   def get_natoms(self):
     return self.lib.lammps_get_natoms(self.lmp)
-
+  
   def get_coords(self):
     nlen = 3 * self.lib.lammps_get_natoms(self.lmp)
     coords = (c_double*nlen)()
     self.lib.lammps_get_coords(self.lmp,coords)
     return coords
-
+  
   # assume coords is an array of c_double, as created by get_coords()
   # could check if it is some other Python object and create c_double array?
   # constructor for c_double array can take an arg to use to fill it?
Index: src/integer_parsing.h
===================================================================
--- src/integer_parsing.h	(revision 0)
+++ src/integer_parsing.h	(revision 0)
@@ -0,0 +1,31 @@
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+/* ----------------------------------------------------------------------
+   This file contributed by Joe Jordan (joe.jordan@imperial.ac.uk)
+
+   This file uses the method recommended here:
+
+   http://stackoverflow.com/questions/194465/how-to-parse-a-string-to-an-int-in-c
+
+   as the simplest and fastest way in C or C++ to parse integers from a string.
+------------------------------------------------------------------------- */
+
+#ifndef INT_PARSING_EXTN_JFJ
+#define INT_PARSING_EXTN_JFJ 1
+
+enum STR2INT_ERROR { STR2INT_SUCCESS, STR2INT_OVERFLOW, STR2INT_UNDERFLOW, STR2INT_INCONVERTIBLE };
+
+STR2INT_ERROR str2int (int &i, char const *s, int base = 0);
+
+#endif
Index: src/delete_atoms.h
===================================================================
--- src/delete_atoms.h	(revision 8389)
+++ src/delete_atoms.h	(working copy)
@@ -37,6 +37,7 @@
   void delete_region(int, char **);
   void delete_overlap(int, char **);
   void delete_porosity(int, char **);
+  void delete_ids(int, char **);
   void options(int, char **);
 
   inline int sbmask(int j) {
Index: src/delete_atoms.cpp
===================================================================
--- src/delete_atoms.cpp	(revision 8389)
+++ src/delete_atoms.cpp	(working copy)
@@ -27,6 +27,7 @@
 #include "random_mars.h"
 #include "memory.h"
 #include "error.h"
+#include "integer_parsing.h"
 
 using namespace LAMMPS_NS;
 
@@ -54,6 +55,7 @@
   else if (strcmp(arg[0],"region") == 0) delete_region(narg,arg);
   else if (strcmp(arg[0],"overlap") == 0) delete_overlap(narg,arg);
   else if (strcmp(arg[0],"porosity") == 0) delete_porosity(narg,arg);
+  else if (strcmp(arg[0],"ids") == 0) delete_ids(narg, arg);
   else error->all(FLERR,"Illegal delete_atoms command");
 
   // delete local atoms flagged in dlist
@@ -137,6 +139,41 @@
 }
 
 /* ----------------------------------------------------------------------
+   delete all atoms listed by id.
+------------------------------------------------------------------------- */
+
+void DeleteAtoms::delete_ids(int narg, char **arg)
+{
+  if (narg < 2) error->all(FLERR,"Illegal delete_atoms command");
+
+  int nlocal = atom->nlocal;
+
+  int local_narg = narg;
+  if (strcmp(arg[narg-2], "compress") == 0) {
+    local_narg -= 2;
+  }
+  // parse the ids passed in the args.
+  int* ids_to_delete = (int*)malloc(sizeof(int) * (local_narg-1));
+  for (int i = 1; i < local_narg; i++) {
+    if (str2int(ids_to_delete[i-1], arg[i]) != STR2INT_SUCCESS) {
+      error->all(FLERR,"Illegal delete_atoms command: unrecognised atom id.");
+    }
+    if (ids_to_delete[i-1] > nlocal) {
+      error->all(FLERR,"Illegal delete_atoms command: atom id out of bounds.");
+    }
+  }
+
+  // allocate and initialize deletion list
+  memory->create(dlist,nlocal,"delete_atoms:dlist");
+  for (int i = 0; i < nlocal; i++) dlist[i] = 0;
+
+  for (int i = 0; i < local_narg - 1; i++)
+    dlist[ids_to_delete[i]] = 1;
+
+  free(ids_to_delete);
+}
+
+/* ----------------------------------------------------------------------
    delete all atoms in region
 ------------------------------------------------------------------------- */
 
Index: src/atom.cpp
===================================================================
--- src/atom.cpp	(revision 8389)
+++ src/atom.cpp	(working copy)
@@ -1626,6 +1626,10 @@
   if (strcmp(name,"f") == 0) return (void *) f;
   if (strcmp(name,"mass") == 0) return (void *) mass;
   if (strcmp(name,"rmass") == 0) return (void *) rmass;
+  if (strcmp(name,"omega") == 0) return (void *) omega;
+  if (strcmp(name,"angmom") == 0) return (void *) angmom;
+  if (strcmp(name,"torque") == 0) return (void *) torque;
+  if (strcmp(name,"radius") == 0) return (void *) radius;
 
   return NULL;
 }
Index: src/integer_parsing.cpp
===================================================================
--- src/integer_parsing.cpp	(revision 0)
+++ src/integer_parsing.cpp	(revision 0)
@@ -0,0 +1,46 @@
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   http://lammps.sandia.gov, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+/* ----------------------------------------------------------------------
+   This file contributed by Joe Jordan (joe.jordan@imperial.ac.uk)
+
+   This file uses the method recommended here:
+
+   http://stackoverflow.com/questions/194465/how-to-parse-a-string-to-an-int-in-c
+
+   as the simplest way in C or C++ to parse integers from a string.
+------------------------------------------------------------------------- */
+
+#include <stdlib.h>
+#include <cerrno>
+#include <climits>
+#include "integer_parsing.h"
+
+STR2INT_ERROR str2int (int &i, char const *s, int base)
+{
+    char *end;
+    long  l;
+    errno = 0;
+    l = strtol(s, &end, base);
+    if ((errno == ERANGE && l == LONG_MAX) || l > INT_MAX) {
+        return STR2INT_OVERFLOW;
+    }
+    if ((errno == ERANGE && l == LONG_MIN) || l < INT_MIN) {
+        return STR2INT_UNDERFLOW;
+    }
+    if (*s == '\0' || *end != '\0') {
+        return STR2INT_INCONVERTIBLE;
+    }
+    i = l;
+    return STR2INT_SUCCESS;
+}
